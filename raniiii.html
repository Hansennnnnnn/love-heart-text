<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>I love you rannn — 3D Heart</title>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      background: radial-gradient(60% 60% at 50% 50%, #0b0b12 0%, #000 70%);
      color: #bbb;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    }
    #app { position: fixed; inset: 0; }
    #hint {
      position: fixed;
      left: 50%;
      bottom: 14px;
      transform: translateX(-50%);
      font-size: 12px;
      opacity: .6;
      user-select: none;
    }
    #hint code { color: #ddd; }
  </style>
</head>
<body>
  <div id="app"></div>
  <div id="hint">
    Tip: add <code>?text=Your%20Message</code> to the URL to change the words.
  </div>

  <!-- Three.js -->
  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.160.0/examples/js/controls/OrbitControls.js"></script>

  <script>
    // ---------- helpers ----------
    function getQueryText() {
      const url = new URL(window.location.href);
      const t = url.searchParams.get("text");
      return (t && t.trim()) ? t.trim() : "I love you rannn";
    }

    function makeTextTexture(message) {
      const canvas = document.createElement("canvas");
      canvas.width = 2048; canvas.height = 256;
      const ctx = canvas.getContext("2d");

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = "rgba(255, 120, 150, 0.06)";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.font = "bold 120px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.textBaseline = "middle";
      ctx.shadowColor = "rgba(255,120,150,0.6)";
      ctx.shadowBlur = 12;
      ctx.fillStyle = "#ffd1dc";

      const spacer = "   •   ";
      const line = (message + spacer).repeat(100);

      for (let row = 0; row < 3; row++) {
        const y = (canvas.height / 2) + (row - 1) * 70;
        ctx.fillText(line, -50, y);
      }

      const tex = new THREE.CanvasTexture(canvas);
      tex.wrapS = THREE.RepeatWrapping;
      tex.wrapT = THREE.RepeatWrapping;
      tex.repeat.set(8, 6);
      tex.anisotropy = 8;
      tex.needsUpdate = true;
      return tex;
    }

    class HeartCurve extends THREE.Curve {
      constructor(scale = 1) { super(); this.scale = scale; }
      getPoint(t, optionalTarget = new THREE.Vector3()) {
        const a = t * Math.PI * 2;
        const x = 16 * Math.pow(Math.sin(a), 3);
        const y = 13 * Math.cos(a) - 5 * Math.cos(2*a) - 2 * Math.cos(3*a) - Math.cos(4*a);
        const z = 2.0 * Math.sin(3 * a);
        return optionalTarget.set(x * this.scale, y * this.scale, z * this.scale);
      }
    }

    // ---------- scene ----------
    const container = document.getElementById("app");
    const scene = new THREE.Scene();

    const camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 1000);
    camera.position.set(0, 10, 75);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(container.clientWidth, container.clientHeight);
    container.appendChild(renderer.domElement);

    const hemi = new THREE.HemisphereLight(0xff88aa, 0x080820, 0.8);
    scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 0.8);
    dir.position.set(20, 30, 40);
    scene.add(dir);

    const message = getQueryText();
    const texture = makeTextTexture(message);

    const path = new HeartCurve(0.8);
    const tubeGeo = new THREE.TubeGeometry(path, 1200, 3.2, 48, true);

    const mat = new THREE.MeshStandardMaterial({
      map: texture,
      emissive: new THREE.Color(0xff6b8f),
      emissiveMap: texture,
      emissiveIntensity: 0.35,
      metalness: 0.15,
      roughness: 0.3
    });

    const heartMesh = new THREE.Mesh(tubeGeo, mat);
    scene.add(heartMesh);

    const rimMat = new THREE.MeshBasicMaterial({
      color: 0xff9bb4,
      transparent: true,
      opacity: 0.12,
      side: THREE.BackSide
    });
    const rim = new THREE.Mesh(tubeGeo.clone(), rimMat);
    rim.scale.multiplyScalar(1.04);
    scene.add(rim);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.enablePan = false;
    controls.autoRotate = true;
    controls.autoRotateSpeed = 0.8;

    function onResize() {
      const { clientWidth: w, clientHeight: h } = container;
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
      renderer.setSize(w, h);
    }
    window.addEventListener("resize", onResize);

    let t = 0;
    function tick() {
      requestAnimationFrame(tick);
      t += 0.005;
      heartMesh.rotation.y += 0.0035;
      heartMesh.rotation.x = Math.sin(t) * 0.08;
      rim.rotation.copy(heartMesh.rotation);
      controls.update();
      renderer.render(scene, camera);
    }
    tick();
  </script>
</body>
</html>